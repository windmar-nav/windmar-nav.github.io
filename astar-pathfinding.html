<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WindMar - A* Pathfinding for Maritime Weather Routing</title>
    <link rel="stylesheet" href="assets/css/docs.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
</head>
<body>

<!-- Header -->
<header class="docs-header">
    <div class="docs-header-content">
        <a href="docs.html" class="docs-logo">
            <i class="fas fa-ship"></i>
            <span>WindMar</span>
        </a>
        <nav>
            <ul class="docs-nav">
                <li><a href="docs.html">Documentation</a></li>
                <li class="docs-nav-dropdown">
                    <a href="#">Technical Articles <i class="fas fa-caret-down"></i></a>
                    <ul class="docs-nav-dropdown-menu">
                        <li><a href="weather-fields.html">Weather Fields</a></li>
                        <li><a href="data-pipeline.html">Data Pipeline</a></li>
                        <li><a href="hydrodynamics.html">Hydrodynamics &amp; RAO</a></li>
                        <li><a href="astar-pathfinding.html" class="active">A* Pathfinding</a></li>
                        <li><a href="route-optimization-engines.html">Optimization Engines</a></li>
                        <li><a href="weather-data.html">Weather Acquisition</a></li>
                        <li><a href="monte-carlo.html">Monte Carlo</a></li>
                        <li><a href="open-problems.html">Open Problems</a></li>
                    </ul>
                </li>
                <li><a href="https://github.com/windmar-nav/windmar" target="_blank"><i class="fab fa-github"></i> GitHub</a></li>
                <li><a href="https://demo-windmar.slmar.co" target="_blank" class="demo-nav-link"><i class="fas fa-play-circle"></i> Live Demo</a></li>
            </ul>
        </nav>
        <a href="https://slmar.co" class="back-to-main"><i class="fas fa-arrow-left"></i> Back to Main Site</a>
    </div>
</header>

<!-- Main Layout -->
<div class="docs-container">

    <!-- Sidebar -->
    <aside class="docs-sidebar">

        <div class="sidebar-section">
            <div class="sidebar-title">Article</div>
            <ul class="sidebar-menu">
                <li><a href="#abstract"><i class="fas fa-file-alt"></i> Abstract</a></li>
                <li><a href="#introduction"><i class="fas fa-book-open"></i> Introduction</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Problem</div>
            <ul class="sidebar-menu">
                <li><a href="#problem-formulation"><i class="fas fa-crosshairs"></i> Problem Formulation</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Graph Model</div>
            <ul class="sidebar-menu">
                <li><a href="#graph-construction"><i class="fas fa-th"></i> Graph Construction</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Cost Function</div>
            <ul class="sidebar-menu">
                <li><a href="#astar-algorithm"><i class="fas fa-search"></i> A* Search</a></li>
                <li><a href="#voyage-calculator"><i class="fas fa-calculator"></i> Voyage Calculator</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Optimization</div>
            <ul class="sidebar-menu">
                <li><a href="#route-smoothing"><i class="fas fa-bezier-curve"></i> Route Smoothing</a></li>
                <li><a href="#temporal-weather"><i class="fas fa-clock"></i> Temporal Weather</a></li>
                <li><a href="#performance"><i class="fas fa-tachometer-alt"></i> Performance</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Resources</div>
            <ul class="sidebar-menu">
                <li><a href="#references"><i class="fas fa-bookmark"></i> References</a></li>
                <li><a href="docs.html"><i class="fas fa-arrow-left"></i> Back to Docs</a></li>
                <li><a href="https://github.com/windmar-nav/windmar" target="_blank"><i class="fab fa-github"></i> GitHub</a></li>
            </ul>
        </div>

    </aside>

    <!-- Main Content -->
    <main class="docs-main">
        <div class="docs-content">

            <!-- ============================================================ -->
            <!-- ABSTRACT -->
            <!-- ============================================================ -->
            <section id="abstract">
                <h1>A* Pathfinding for Maritime Weather Routing</h1>
                <p class="docs-subtitle">Adaptation of A* graph search to minimum-fuel ocean routing with physics-based cost evaluation and time-varying weather</p>

                <div class="alert info">
                    <strong><i class="fas fa-info-circle"></i> Technical Article</strong><br>
                    This article presents the graph-based route optimization engine at the core of WindMar.
                    It covers the construction of a navigable ocean grid, the adaptation of the A* search
                    algorithm to minimise fuel consumption under weather forcing, the physics-based cost
                    function that couples vessel hydrodynamics with environmental conditions at each leg,
                    and the post-processing steps that smooth and refine the optimal path.
                </div>

                <h3>Abstract</h3>
                <p>
                    The A* algorithm, originally developed for shortest-path search in weighted graphs,
                    is adapted here for minimum-fuel ocean routing subject to time-varying meteorological
                    and oceanographic conditions. WindMar discretises the ocean surface into a regular
                    latitude-longitude grid at configurable resolution (default 0.5&deg;, approximately
                    30 nautical miles at the equator) with eight-connected cell adjacency. Land cells
                    are excluded using a high-resolution global land mask, and the search corridor is
                    bounded by a configurable margin around the great-circle path between origin and
                    destination. The cost function at each edge evaluates fuel consumption via the full
                    <a href="hydrodynamics.html">hydrodynamic vessel model</a>, incorporating wind
                    resistance, wave-added resistance, and ocean current effects on speed over ground.
                    An admissible heuristic based on great-circle distance, maximum attainable speed,
                    and a conservative fuel rate ensures that the search terminates with a provably
                    optimal path. Post-processing applies Douglas-Peucker simplification with land-crossing
                    checks to reduce waypoint density, followed by optional variable-speed optimisation
                    across the smoothed route. The complete pipeline &mdash; grid construction, A* search,
                    smoothing, and route statistics &mdash; executes in 0.5&ndash;2 seconds for typical
                    Mediterranean routes, enabling interactive use in the WindMar web application.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- INTRODUCTION -->
            <!-- ============================================================ -->
            <section id="introduction">
                <h2>1. Introduction</h2>

                <p>
                    The problem of finding an optimal route for a vessel across an ocean subject to
                    environmental forcing has attracted sustained attention since Dijkstra (1959)
                    established the theoretical foundations for shortest-path search in weighted graphs.
                    Hart, Nilsson, and Raphael (1968) extended Dijkstra's algorithm with a heuristic
                    estimate of the remaining cost to the goal, producing the A* algorithm that retains
                    optimality guarantees while substantially reducing the number of nodes explored.
                    Hagiwara (1989) was among the first to apply graph-search methods to maritime weather
                    routing, constructing isochrone-based routing charts that account for wave-induced
                    speed loss. More recently, Szlapczynska (2015) demonstrated multi-objective
                    weather routing using evolutionary algorithms, and Vettor and Guedes Soares (2016)
                    developed a complete ship weather routing system that integrates vessel performance
                    models with numerical weather prediction data.
                </p>

                <p>
                    WindMar adopts the A* algorithm rather than dynamic programming or evolutionary
                    approaches for several reasons. First, A* with an admissible heuristic guarantees
                    that the returned path is optimal with respect to the cost function, a property that
                    evolutionary algorithms cannot provide without exhaustive evaluation. Second, the
                    heuristic guides the search toward the destination, dramatically reducing the number
                    of cells explored compared to Dijkstra's algorithm, which expands uniformly in all
                    directions. Third, the algorithm's node-expansion structure maps naturally onto a
                    regular geographic grid, where each cell represents a navigable ocean area and each
                    edge represents a candidate leg with computable fuel cost. The physics-based cost
                    evaluation at each edge draws on the <a href="hydrodynamics.html">hydrodynamic
                    vessel model</a> for resistance and fuel calculations and on the
                    <a href="data-pipeline.html">weather data pipeline</a> for time-varying
                    environmental conditions at each grid point.
                </p>

                <p>
                    This article is organised as follows. Section 2 formulates the optimisation problem.
                    Section 3 describes the construction of the navigable ocean grid. Section 4 presents
                    the A* search algorithm and its adaptation to fuel-minimisation routing. Section 5
                    details the per-leg voyage calculation that underpins the edge cost function. Section 6
                    describes the Douglas-Peucker route smoothing procedure. Section 7 discusses temporal
                    weather integration. Section 8 analyses the computational performance of the pipeline.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- PROBLEM FORMULATION -->
            <!-- ============================================================ -->
            <section id="problem-formulation">
                <h2>2. Problem Formulation</h2>

                <p>
                    The route optimisation problem solved by WindMar can be stated as follows. Given an
                    origin waypoint, a destination waypoint, a departure time, a vessel model with known
                    hydrodynamic characteristics, and a time-varying weather field covering the transit
                    area, find the sequence of intermediate waypoints and (optionally) the speed at each
                    leg that minimises total fuel consumption while satisfying all safety and geographic
                    constraints. The primary objective is fuel minimisation; however, the cost function
                    can incorporate weighted time penalties to produce fuel-time trade-off solutions.
                </p>

                <div class="formula-block">
                    <div class="formula-title">Objective Function</div>
\[ \min \sum_{i=1}^{N} \text{fuel}(\text{leg}_i) \]
<div class="formula-where">
subject to:<br>
&nbsp;&nbsp;\( \text{safety\_status}(\text{leg}_i) \ne \text{DANGEROUS} \quad \forall\, i \)<br>
&nbsp;&nbsp;\( \text{waypoint}_i \in \text{ocean} \quad \forall\, i \)<br>
&nbsp;&nbsp;\( \text{waypoint}_i \notin \text{exclusion\_zones} \quad \forall\, i \)<br>
&nbsp;&nbsp;\( 6.0 \le \text{speed}_i \le 18.0 \;\text{kts} \quad \forall\, i \)
</div>
                </div>

                <p>
                    The decision variables are the geographic positions of intermediate waypoints
                    (constrained to lie on ocean grid cells) and, when variable-speed optimisation is
                    enabled, the vessel speed at each leg. The fuel consumption at each leg is not a
                    simple function of distance; it depends on the wind, wave, and current conditions
                    encountered, the vessel's heading relative to the environmental forcing, and the
                    chosen speed. This coupling between route geometry and environmental conditions
                    makes the problem inherently non-linear and motivates the use of graph search
                    with physics-based edge cost evaluation rather than analytic optimisation.
                </p>

                <p>
                    Safety constraints are enforced through a multiplicative cost factor. The
                    <code>safety_constraints.get_safety_cost_factor()</code> method evaluates seakeeping
                    criteria (roll angle, pitch angle, vertical acceleration) at each candidate leg and
                    returns a factor of 1.0 for safe conditions, a value greater than 1.0 for marginal
                    conditions (penalising but not prohibiting the leg), and infinity for dangerous
                    conditions (effectively blocking the leg from the search). Geographic constraints
                    are enforced by excluding land cells from the grid and applying zone penalties via
                    <code>zone_checker.get_path_penalty()</code>, which returns a multiplicative factor
                    for legs that traverse restricted or undesirable areas.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- GRAPH CONSTRUCTION -->
            <!-- ============================================================ -->
            <section id="graph-construction">
                <h2>3. Graph Construction</h2>

                <p>
                    The search graph is constructed as a regular latitude-longitude grid covering a
                    corridor around the great-circle path between origin and destination. The
                    <code>RouteOptimizer._build_grid()</code> method creates this grid with the
                    following procedure. First, the latitude and longitude extents of the origin and
                    destination are computed, and a configurable margin (default
                    <code>margin_deg=5.0</code>) is added on all sides to allow the search to explore
                    routes that deviate from the direct path. The grid is then populated with cells at
                    the configured resolution, where each cell is represented by a <code>GridCell</code>
                    dataclass containing its latitude, longitude, row index, and column index. The
                    <code>GridCell</code> is hashable, enabling efficient use in Python sets and
                    dictionaries for the closed set and g-score lookup table.
                </p>

                <p>
                    Land filtering is performed by querying the <code>global_land_mask</code> library
                    at each grid point. Any cell classified as land is excluded from the grid dictionary,
                    producing an ocean-only navigable graph. This filtering is critical for preventing the
                    A* search from generating routes that cross landmasses. The land mask operates at
                    approximately 0.05&deg; resolution, which is finer than the default routing grid
                    resolution of 0.5&deg;, ensuring that narrow straits and coastal passages are
                    correctly classified. Further details on the ocean masking procedure are provided
                    in the <a href="weather-fields.html#ocean-mask">Weather Fields</a> article.
                </p>

                <h3>3.1 Grid Connectivity</h3>
                <p>
                    Each cell is connected to its eight immediate neighbours in a regular grid topology:
                    north, northeast, east, southeast, south, southwest, west, and northwest. The eight
                    direction vectors are defined as the constant
                    <code>DIRECTIONS = [(-1,0), (-1,1), (0,1), (1,1), (1,0), (1,-1), (0,-1), (-1,-1)]</code>,
                    where tuple elements represent (row_delta, col_delta). Cardinal moves (N, E, S, W)
                    traverse one grid cell spacing, while diagonal moves (NE, SE, SW, NW) traverse a
                    distance of &radic;2 times the cell spacing. The actual geographic distance for each
                    move is computed via the haversine formula rather than Euclidean approximation,
                    ensuring correct distance calculation at all latitudes where the longitudinal spacing
                    of a 0.5&deg; grid varies from approximately 30 nm at the equator to approximately
                    15 nm at 60&deg; latitude.
                </p>

                <h3>3.2 Grid Parameters</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Default Value</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Resolution</td>
                            <td>0.5&deg; (~30 nm at equator)</td>
                            <td>Spacing between adjacent grid cells in degrees</td>
                        </tr>
                        <tr>
                            <td>Connectivity</td>
                            <td>8-connected</td>
                            <td>Each cell connects to 8 neighbours (cardinal + diagonal)</td>
                        </tr>
                        <tr>
                            <td>Corridor margin</td>
                            <td>5.0&deg;</td>
                            <td>Extra margin around the direct path bounding box</td>
                        </tr>
                        <tr>
                            <td>Maximum cells</td>
                            <td>50,000</td>
                            <td>Upper limit on total grid cells to bound memory and computation</td>
                        </tr>
                        <tr>
                            <td>Land filtering</td>
                            <td>Enabled</td>
                            <td>Exclude land cells via <code>global_land_mask</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>3.3 Haversine Distance</h3>
                <p>
                    All distance calculations between grid cells use the haversine formula with the
                    Earth radius set to 3440.065 nautical miles. This value is the standard mean Earth
                    radius (6371 km) converted to nautical miles and provides sub-0.3% accuracy for
                    the distance ranges encountered in ocean routing (tens to thousands of nautical miles).
                </p>

                <div class="formula-block">
                    <div class="formula-title">Haversine Distance Formula</div>
\[ a = \sin^2\!\Bigl(\frac{\Delta\phi}{2}\Bigr) + \cos(\phi_1)\,\cos(\phi_2)\,\sin^2\!\Bigl(\frac{\Delta\lambda}{2}\Bigr) \]
\[ d = 2\,R\;\arctan2\!\bigl(\sqrt{a},\;\sqrt{1-a}\bigr) \]
<div class="formula-where">
where \( \phi_1, \phi_2 \) = latitudes in radians<br>
\( \Delta\phi = \phi_2 - \phi_1 \)<br>
\( \Delta\lambda = \lambda_2 - \lambda_1 \) (longitude difference)<br>
\( R = 3440.065 \) nm (Earth radius in nautical miles)<br>
\( d \) = great-circle distance in nautical miles
</div>
                </div>

                <p>
                    The initial bearing from one cell to another is computed using the standard
                    two-argument arctangent formula:
                </p>

                <div class="formula-block">
                    <div class="formula-title">Initial Bearing Calculation</div>
\[ \theta = \arctan2\!\bigl(\sin(\Delta\lambda)\,\cos(\phi_2),\;\cos(\phi_1)\,\sin(\phi_2) - \sin(\phi_1)\,\cos(\phi_2)\,\cos(\Delta\lambda)\bigr) \]
\[ \text{bearing} = \bigl(\theta \times \tfrac{180}{\pi}\bigr) \bmod 360 \]
<div class="formula-where">
where the result is in degrees clockwise from true north
</div>
                </div>
            </section>

            <!-- ============================================================ -->
            <!-- A* SEARCH ALGORITHM -->
            <!-- ============================================================ -->
            <section id="astar-algorithm">
                <h2>4. A* Search Algorithm</h2>

                <p>
                    The A* search implemented in <code>RouteOptimizer._astar_search()</code> operates on
                    the ocean grid constructed in the previous section. The algorithm maintains three
                    principal data structures: (1) an open set implemented as a min-heap priority queue
                    of <code>SearchNode</code> objects ordered by f-score, (2) a dictionary
                    <code>g_scores</code> mapping grid cell coordinates (row, col) to the best-known
                    accumulated cost from the origin, and (3) a closed set of fully expanded cells.
                    Each <code>SearchNode</code> encapsulates the cell's f-score, the cell itself, the
                    accumulated g-score, the estimated arrival time at that cell, and a reference to the
                    parent node for path reconstruction.
                </p>

                <h3>4.1 Cost Function Components</h3>
                <p>
                    The evaluation function for each node follows the standard A* formulation:
                </p>

                <div class="formula-block">
                    <div class="formula-title">A* Evaluation Function</div>
\[ f(n) = g(n) + h(n) \]
<div class="formula-where">
where \( g(n) \) = actual accumulated fuel cost from origin to node \( n \) (metric tonnes)<br>
\( h(n) \) = admissible heuristic estimate of remaining fuel cost from \( n \) to destination<br>
\( f(n) \) = estimated total fuel cost of the cheapest path through \( n \)
</div>
                </div>

                <p>
                    The g-score <code>g(n)</code> represents the actual accumulated fuel consumption
                    from the origin to node n, computed by summing the fuel costs of all legs along the
                    path. Each leg's fuel cost is evaluated by <code>_calculate_move_cost()</code>, which
                    queries the weather provider at the midpoint of the leg for the estimated arrival
                    time, computes fuel consumption via the vessel hydrodynamic model, adjusts for ocean
                    current effects on speed over ground, and applies safety and zone penalty multipliers.
                    The cost returned is the product of fuel consumption in metric tonnes, the safety
                    cost factor, and any zone penalty factor.
                </p>

                <h3>4.2 Admissible Heuristic</h3>
                <p>
                    The heuristic <code>h(n)</code> must never overestimate the true remaining cost for
                    A* to guarantee optimality. WindMar computes the heuristic as the great-circle
                    distance from the current cell to the destination, divided by the maximum attainable
                    service speed, multiplied by the fuel consumption rate, and then scaled by a factor
                    of 0.8. The 0.8 multiplier provides a deliberate underestimate: even under the most
                    favourable conditions (following currents, calm seas), the actual fuel consumption
                    per nautical mile will exceed this conservative estimate. This ensures admissibility
                    across all possible weather conditions while still providing sufficient guidance to
                    focus the search toward the destination.
                </p>

                <div class="formula-block">
                    <div class="formula-title">Admissible Heuristic</div>
\[ h(n) = \frac{d_{\text{gc}}(n, \text{goal})}{v_{\max}} \times r_{\text{fuel}} \times 0.8 \]
<div class="formula-where">
where \( d_{\text{gc}} \) = great-circle distance from \( n \) to destination (nm)<br>
\( v_{\max} \) = maximum service speed (kts)<br>
\( r_{\text{fuel}} \) = fuel consumption rate (mt/hour)<br>
0.8 = underestimate factor guaranteeing admissibility
</div>
                </div>

                <h3>4.3 Node Expansion</h3>
                <p>
                    At each iteration, the algorithm pops the node with the lowest f-score from the
                    open set. If this node is the destination cell, the search terminates and the
                    optimal path is reconstructed by following parent pointers from the destination
                    back to the origin. Otherwise, the node is added to the closed set and its eight
                    neighbours are examined. For each neighbour that is present in the ocean grid (i.e.,
                    not land and not outside the corridor) and not already in the closed set, the
                    algorithm computes the tentative g-score as the current node's g-score plus the
                    move cost to the neighbour. If this tentative g-score is lower than any previously
                    recorded g-score for that neighbour, the neighbour's record is updated and it is
                    pushed onto the open set with the new f-score. The search terminates either when
                    the destination is reached or when the number of explored cells exceeds
                    <code>max_cells</code> (default 50,000), a safeguard against excessive computation
                    in pathological cases.
                </p>

                <h3>4.4 Pseudocode</h3>
                <pre><code>OPEN &larr; priority queue with start node (f=h(start), g=0)
CLOSED &larr; empty set
g_scores &larr; {start: 0}

while OPEN is not empty:
    node &larr; pop minimum f from OPEN
    if node is destination: return reconstruct_path(node)
    add node to CLOSED

    for each neighbor in 8-connected(node):
        if neighbor in CLOSED or neighbor is land: continue

        cost, time &larr; calculate_move_cost(node, neighbor)
        tentative_g &larr; node.g + cost

        if tentative_g &lt; best_g[neighbor]:
            best_g[neighbor] &larr; tentative_g
            neighbor.parent &larr; node
            neighbor.arrival_time &larr; node.arrival_time + time
            push neighbor to OPEN with f = tentative_g + h(neighbor)

return failure (no path found within max_cells)</code></pre>

                <h3>4.5 Edge Cost Evaluation</h3>
                <p>
                    The <code>_calculate_move_cost()</code> method is the most computationally intensive
                    component of each node expansion. For a candidate move from cell A to cell B, the
                    method performs the following steps. First, it computes the great-circle distance and
                    initial bearing between the two cells using the haversine formula. Second, it queries
                    the weather provider at the geographic midpoint of the leg for the estimated arrival
                    time at that midpoint, obtaining wind, wave, and current conditions. Third, it passes
                    the environmental conditions and vessel heading to the vessel model's
                    <code>calculate_fuel_consumption()</code> method, which returns the fuel consumed in
                    metric tonnes for the leg. Fourth, it computes the effect of ocean currents on speed
                    over ground: the current velocity component along the vessel's heading is projected
                    using <code>effect = current_kts &times; cos(relative_angle)</code>, and the speed
                    over ground is computed as <code>sog = stw + current_component</code>. Fifth, the
                    safety cost factor and zone penalty are retrieved and multiplied into the final cost.
                    The method returns a tuple of (cost, travel_time_hours), where the cost is
                    <code>fuel_mt &times; safety_factor &times; zone_penalty</code>.
                </p>

                <div class="alert info">
                    <strong><i class="fas fa-info-circle"></i> Safety Factor Interpretation</strong><br>
                    The safety cost factor returned by <code>safety_constraints.get_safety_cost_factor()</code>
                    operates as a soft constraint. A factor of 1.0 indicates safe conditions with no penalty.
                    Factors between 1.0 and infinity represent increasingly marginal conditions that the
                    optimiser will avoid unless no safer alternative exists. A factor of infinity (&infin;)
                    represents dangerous conditions that completely block the leg, forcing the search to
                    find an alternative path around the hazardous area.
                </div>

                <h3>4.6 Time Penalty (v0.0.6)</h3>
                <p>
                    The A* cost function is fuel-only by default, which can cause the search to choose long detours
                    around weather systems even when the fuel savings are marginal. To mitigate this, the cost function
                    includes a time penalty term:
                </p>
                <div class="formula-block">
                    <div class="formula-title">Penalised Edge Cost</div>
\[ c(m, n) = \text{fuel}_{mn} \times \text{safety}_{mn} \times \text{zone}_{mn} + \lambda_t \times t_{mn} \times r_{\text{service}} \]
<div class="formula-where">
where \( \lambda_t \) = time penalty weight (set to 1.0 since v0.0.6, previously 0.5)<br>
\( t_{mn} \) = transit time for the leg (hours)<br>
\( r_{\text{service}} \) = fuel consumption rate at service speed (mt/h), making the penalty dimensionally consistent with fuel cost
</div>
                </div>
                <p>
                    Increasing \(\lambda_t\) from 0.5 to 1.0 penalises time-consuming detours more strongly, preventing
                    long zigzag paths that save minimal fuel at the cost of significantly longer voyage times. The
                    smoothing tolerance is also scaled to the grid resolution (one cell diagonal) to reduce waypoint
                    count in proportion to the search grid density.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- VOYAGE CALCULATOR -->
            <!-- ============================================================ -->
            <section id="voyage-calculator">
                <h2>5. Per-Leg Voyage Calculation</h2>

                <p>
                    Once the A* search has produced an optimal waypoint sequence, the
                    <code>VoyageCalculator</code> class performs a detailed per-leg analysis of the
                    route. This class is also invoked during the search itself (via the move cost
                    function) to evaluate candidate legs, but its primary role is to produce the
                    comprehensive <code>VoyageResult</code> that includes per-leg breakdowns of
                    distance, bearing, weather, speed loss, fuel consumption, and power requirements.
                    The calculator processes each leg sequentially, accumulating departure and arrival
                    times to ensure that weather queries reflect the vessel's actual temporal position
                    along the route.
                </p>

                <h3>5.1 Leg Performance Calculation</h3>
                <p>
                    For each leg, the <code>_calculate_leg_performance()</code> method determines the
                    vessel's achievable speed through water (STW) and the corresponding fuel consumption.
                    The method first evaluates the total resistance at the commanded calm-water speed
                    using the hydrodynamic model, which sums calm-water hull resistance, wind resistance
                    (Blendermann model), and wave-added resistance (STA-wave method). The required
                    propulsive power is then compared against 90% of the vessel's maximum continuous
                    rating (MCR). If the required power is within limits, the vessel maintains the
                    commanded speed. If the required power exceeds 90% MCR, the vessel must reduce
                    speed involuntarily, and the reduction factor is computed using the cube law
                    relationship between power and speed.
                </p>

                <div class="formula-block">
                    <div class="formula-title">Involuntary Speed Reduction (Cube Law)</div>
<div class="formula-where">
If \( P_{\text{required}} > 0.9 \times P_{\text{MCR}} \):
</div>
\[ \text{speed\_reduction\_factor} = \left(\frac{P_{\text{available}}}{P_{\text{required}}}\right)^{1/3} \]
\[ \text{STW}_{\text{actual}} = \text{STW}_{\text{commanded}} \times \text{speed\_reduction\_factor} \]
<div class="formula-where">
This follows from the cubic relationship \( P \propto v^3 \):<br>
reducing speed by factor \( k \) reduces power by factor \( k^3 \);<br>
equivalently, reducing power by factor \( m \) reduces speed by factor \( m^{1/3} \)
</div>
                </div>

                <p>
                    After determining the actual STW (with or without involuntary speed reduction),
                    the method recalculates resistance and fuel consumption at the reduced speed. The
                    speed loss percentage is recorded in the <code>LegResult</code> for diagnostic
                    purposes, enabling the user to identify legs where heavy weather forced a
                    significant departure from the planned speed.
                </p>

                <h3>5.2 Current Effect on Speed Over Ground</h3>
                <p>
                    The speed over ground (SOG) is computed by vector addition of the vessel's STW
                    along its heading and the ocean current vector. The
                    <code>VoyageCalculator._calculate_sog()</code> method decomposes both the vessel
                    velocity and the current velocity into north and east components, sums the
                    components, and computes the magnitude of the resultant vector. This approach
                    correctly handles currents from any direction relative to the vessel heading,
                    including beam currents that alter the vessel's course-made-good without changing
                    the scalar SOG along the planned track.
                </p>

                <p>
                    In the simplified current model used within the A* move cost evaluation
                    (<code>_calculate_current_effect()</code>), the current effect is projected along
                    the vessel heading as a scalar component: the relative angle between the vessel's
                    heading and the current direction is computed, and the along-track current component
                    is <code>current_kts &times; cos(relative_angle)</code>. A positive component
                    (following current) increases SOG and reduces passage time; a negative component
                    (opposing current) decreases SOG and increases both passage time and fuel consumption
                    per nautical mile of ground track.
                </p>

                <h3>5.3 Per-Leg Output Fields</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Field</th>
                            <th>Units</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>distance_nm</code></td>
                            <td>nm</td>
                            <td>Great-circle distance of the leg</td>
                        </tr>
                        <tr>
                            <td><code>bearing_deg</code></td>
                            <td>degrees</td>
                            <td>Initial bearing from leg start to end</td>
                        </tr>
                        <tr>
                            <td><code>stw_kts</code></td>
                            <td>kts</td>
                            <td>Actual speed through water (after any involuntary reduction)</td>
                        </tr>
                        <tr>
                            <td><code>sog_kts</code></td>
                            <td>kts</td>
                            <td>Speed over ground (STW adjusted for current)</td>
                        </tr>
                        <tr>
                            <td><code>speed_loss_pct</code></td>
                            <td>%</td>
                            <td>Percentage reduction from commanded speed due to weather</td>
                        </tr>
                        <tr>
                            <td><code>fuel_mt</code></td>
                            <td>mt</td>
                            <td>Fuel consumed on the leg in metric tonnes</td>
                        </tr>
                        <tr>
                            <td><code>power_kw</code></td>
                            <td>kW</td>
                            <td>Required propulsive power at the actual speed</td>
                        </tr>
                        <tr>
                            <td><code>time_hours</code></td>
                            <td>hours</td>
                            <td>Transit time for the leg (distance / SOG)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>5.4 Weather Data at Leg Midpoint</h3>
                <p>
                    Weather conditions for each leg are queried at the geographic midpoint of the
                    leg and at the estimated time of arrival at that midpoint. The
                    <code>LegWeather</code> dataclass encapsulates the full set of environmental
                    parameters: wind speed and direction, significant wave height and period, wave
                    direction, current speed and direction, and (when available) decomposed wind-wave
                    and swell components. The decomposition flag <code>has_decomposition</code>
                    determines whether the seakeeping model evaluates vessel motions using the total
                    sea state or the more accurate decomposed approach described in the
                    <a href="hydrodynamics.html">Hydrodynamics &amp; RAO</a> article.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- ROUTE SMOOTHING -->
            <!-- ============================================================ -->
            <section id="route-smoothing">
                <h2>6. Route Smoothing</h2>

                <p>
                    The raw path produced by the A* search consists of waypoints aligned to the
                    regular grid, resulting in a staircase-like trajectory with unnecessary
                    intermediate points. The <code>RouteOptimizer._smooth_path()</code> method
                    applies the Douglas-Peucker line simplification algorithm (Douglas and Peucker,
                    1973) to reduce the waypoint count while preserving the essential shape of the
                    route. This is a standard cartographic technique that recursively identifies
                    and removes waypoints whose perpendicular distance from the line connecting
                    their neighbours falls below a specified tolerance.
                </p>

                <p>
                    WindMar configures the simplification tolerance at <code>tolerance_nm=5.0</code>
                    nautical miles, meaning that any waypoint whose removal would cause the route to
                    deviate by less than 5 nm from its original shape is discarded. This value
                    represents a balance between route fidelity (preserving the optimiser's chosen
                    deviations around weather systems) and waypoint economy (reducing the number of
                    legs that must be individually evaluated for fuel consumption and safety).
                </p>

                <h3>6.1 Douglas-Peucker Algorithm</h3>
                <p>
                    The algorithm operates recursively on a sequence of waypoints. Given the endpoints
                    of a segment, it finds the intermediate waypoint with the greatest perpendicular
                    distance from the line connecting the endpoints. If this distance exceeds the
                    tolerance, the waypoint is retained and the algorithm recurses on the two
                    sub-segments. If no intermediate waypoint exceeds the tolerance, all intermediate
                    waypoints are removed and the segment is replaced by a direct line. The recursion
                    produces a minimal set of waypoints that approximates the original route within
                    the specified tolerance.
                </p>

                <h3>6.2 Land-Crossing Check</h3>
                <p>
                    A critical extension to the standard Douglas-Peucker algorithm in the maritime
                    context is the land-crossing check. Before simplifying any segment by removing
                    intermediate waypoints, the algorithm verifies that the resulting direct line
                    between the retained endpoints does not cross land. If the simplified segment
                    would cross a landmass, the intermediate waypoint with the greatest distance
                    is retained regardless of whether it exceeds the tolerance, and the recursion
                    proceeds on the sub-segments. This ensures that the smoothed route remains
                    entirely over water, even when the original grid-aligned path detours around
                    peninsulas, islands, or narrow straits.
                </p>

                <h3>6.3 Turn-Angle Filter (v0.0.6)</h3>
                <p>
                    Even after Douglas-Peucker simplification, the 8-connected grid can leave residual
                    staircase artefacts &mdash; pairs of short legs with nearly identical headings separated
                    by a negligible course change. The <code>_remove_small_turns()</code> post-filter
                    iterates over the smoothed waypoints and removes any intermediate waypoint where the
                    course change between the inbound and outbound legs is below a configurable threshold
                    (default: 15&deg;). Before removing a waypoint, the filter verifies that the resulting
                    direct segment does not cross land, preserving the same safety guarantee as the
                    Douglas-Peucker land-crossing check.
                </p>
                <div class="formula-block">
                    <div class="formula-title">Turn-Angle Criterion</div>
                    <p>For consecutive waypoints \(w_{i-1}, w_i, w_{i+1}\):</p>
                    \[\Delta\theta = \left| \left( \theta_{\text{out}} - \theta_{\text{in}} + 180째 \right) \bmod 360째 - 180째 \right|\]
                    <p>If \(\Delta\theta < 15째\) and the segment \(w_{i-1} \to w_{i+1}\) is clear of land, then \(w_i\) is removed.</p>
                </div>

                <h3>6.4 Re-evaluation</h3>
                <p>
                    After smoothing and turn-angle filtering, the route statistics are recalculated using
                    <code>_calculate_route_stats()</code>, which iterates over the smoothed waypoint
                    sequence and computes per-leg distance, bearing, weather, fuel consumption, and
                    safety status. Two speed strategies are then computed (v0.0.6):
                </p>
                <ul>
                    <li><strong>Constant Speed</strong> &mdash; the optimised path is evaluated at the same
                        calm speed used in the voyage baseline, producing a &ldquo;Same Speed&rdquo; scenario</li>
                    <li><strong>Match ETA</strong> &mdash; a time-constrained variable-speed profile is computed
                        using <code>_calculate_route_stats_time_constrained()</code>, which adjusts leg speeds
                        so that total voyage time matches the baseline arrival time, producing maximum fuel savings</li>
                </ul>
                <p>
                    Both scenarios are packaged as <code>SpeedScenario</code> dataclass instances and attached
                    to the <code>OptimizedRoute</code> result alongside the baseline fuel, time, and distance
                    for percentage savings calculation. The smoothed route is also compared against the user&rsquo;s
                    drawn waypoints (not just a simple great-circle) when <code>route_waypoints</code> are
                    provided, ensuring that the baseline comparison reflects the actual intended route.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- TEMPORAL WEATHER INTEGRATION -->
            <!-- ============================================================ -->
            <section id="temporal-weather">
                <h2>7. Temporal Weather Integration</h2>

                <p>
                    A distinguishing feature of WindMar's route optimisation is its use of time-varying
                    weather data throughout the search and route evaluation process. Rather than
                    evaluating all legs against a single weather snapshot at departure time, the system
                    queries weather conditions at the estimated time of arrival at each grid cell during
                    the A* search and at each leg midpoint during the detailed voyage calculation. The
                    <code>TemporalGridWeatherProvider</code> supplies weather data as a function of
                    both geographic position and time, drawing on the multi-timestep forecast grids
                    described in the <a href="data-pipeline.html">Data Pipeline</a> article.
                </p>

                <p>
                    During the A* search, the <code>SearchNode</code> dataclass carries an
                    <code>arrival_time</code> field that tracks the cumulative transit time from the
                    origin. When a node is expanded and its neighbours are evaluated, the move cost
                    function uses the node's arrival time plus half the estimated leg transit time
                    as the query time for the weather provider. This means that the weather conditions
                    used to evaluate a leg in the middle of a five-day voyage reflect the forecast for
                    that future time, not the conditions at departure. The arrival time at the neighbour
                    node is then updated as the parent's arrival time plus the full leg transit time,
                    propagating the temporal position forward through the graph.
                </p>

                <h3>7.1 Impact on Route Selection</h3>
                <p>
                    Temporal weather integration can produce routes that differ significantly from
                    those computed using a static weather snapshot. Consider a vessel departing into
                    calm conditions with a storm system forecast to arrive in 48 hours along the
                    direct path. A static-weather optimiser would see no reason to deviate from the
                    great-circle route, as the departure-time conditions are benign everywhere. The
                    temporal optimiser, by contrast, evaluates the later legs against the forecast
                    storm conditions and may route the vessel on a longer but calmer southerly arc
                    that avoids the worst of the weather. This capability is particularly important
                    for multi-day ocean crossings where weather systems can develop, intensify, and
                    propagate during the voyage.
                </p>

                <h3>7.2 Iterative Time Accumulation</h3>
                <p>
                    The temporal integration introduces a coupling between the route and the weather:
                    the weather encountered depends on when the vessel arrives at each point, which
                    depends on the speed achieved under the weather encountered at earlier points. In
                    the A* search, this coupling is handled implicitly through the arrival time field
                    in each <code>SearchNode</code>. In the post-search voyage calculation, the
                    coupling is handled by sequential iteration over legs, where the departure time
                    of each leg equals the arrival time of the previous leg. This sequential
                    accumulation ensures that the weather query times reflect the vessel's actual
                    temporal trajectory along the route, including any speed reductions caused by
                    adverse conditions on earlier legs. The trilinear interpolation scheme used by
                    the weather provider (spatial bilinear interpolation combined with temporal
                    linear interpolation between forecast time steps) is described in the
                    <a href="data-pipeline.html">Data Pipeline</a> article.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- PERFORMANCE CHARACTERISTICS -->
            <!-- ============================================================ -->
            <section id="performance">
                <h2>8. Performance Characteristics</h2>

                <p>
                    The A* search with an admissible heuristic has a worst-case time complexity of
                    O(N log N), where N is the number of ocean grid cells in the search corridor.
                    The log N factor arises from the heap operations (push and pop) on the priority
                    queue. In practice, the heuristic substantially reduces the number of cells
                    explored: for a Mediterranean route at 0.5&deg; resolution, the search typically
                    explores 2,000&ndash;8,000 cells out of a total grid of 15,000&ndash;30,000
                    ocean cells, achieving an effective pruning ratio of 70&ndash;85%. The number
                    of cells explored is recorded in the <code>OptimizedRoute.cells_explored</code>
                    field and the total optimisation time in <code>optimization_time_ms</code>.
                </p>

                <h3>8.1 Computational Cost Breakdown</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Stage</th>
                            <th>Typical Time</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Grid construction + land filtering</td>
                            <td>50&ndash;200 ms</td>
                            <td>Depends on corridor size; <code>global_land_mask</code> queries dominate</td>
                        </tr>
                        <tr>
                            <td>A* search</td>
                            <td>200&ndash;1000 ms</td>
                            <td>Dominated by <code>_calculate_move_cost()</code> calls (weather + vessel model)</td>
                        </tr>
                        <tr>
                            <td>Route smoothing (Douglas-Peucker)</td>
                            <td>&lt; 10 ms</td>
                            <td>Recursive simplification with land checks</td>
                        </tr>
                        <tr>
                            <td>Route statistics + variable speed</td>
                            <td>100&ndash;500 ms</td>
                            <td>Per-leg weather query + 7-speed evaluation when variable speed enabled</td>
                        </tr>
                        <tr>
                            <td>Direct route comparison</td>
                            <td>50&ndash;100 ms</td>
                            <td>Single-leg evaluation for fuel/time savings calculation</td>
                        </tr>
                        <tr>
                            <td><strong>Total pipeline</strong></td>
                            <td><strong>0.5&ndash;2.0 s</strong></td>
                            <td>End-to-end for typical Mediterranean routes</td>
                        </tr>
                    </tbody>
                </table>

                <h3>8.2 Variable-Speed Optimisation</h3>
                <p>
                    When variable-speed optimisation is enabled, the
                    <code>_find_optimal_speed()</code> method evaluates 7 discrete speed steps
                    uniformly distributed across the range 6.0&ndash;18.0 knots
                    (<code>SPEED_RANGE_KTS</code>). For each candidate speed, the method computes
                    the fuel consumption, the effective SOG accounting for currents, the transit
                    time, and the safety cost factor. The scoring criterion depends on the
                    optimisation objective: for fuel optimisation, the method selects the speed
                    that minimises fuel per nautical mile; for time optimisation, it selects the
                    speed that minimises transit time. Safety penalties are applied multiplicatively
                    to the score, ensuring that speeds which produce dangerous vessel motions are
                    heavily penalised even if they are fuel-efficient. The optimal speed, fuel
                    consumption, and transit time are returned as a tuple for incorporation into
                    the leg results.
                </p>

                <h3>8.3 Memory Usage</h3>
                <p>
                    Memory consumption is proportional to the number of grid cells. Each
                    <code>GridCell</code> occupies approximately 64 bytes (four floats plus Python
                    object overhead), and each entry in the g-scores dictionary adds approximately
                    100 bytes (tuple key plus float value plus hash table overhead). For the maximum
                    grid size of 50,000 cells, the total memory footprint of the search data
                    structures is approximately 8 MB, well within the constraints of a web
                    application backend. The <code>SearchNode</code> objects in the priority queue
                    are garbage-collected as nodes are popped and processed, so the queue's peak
                    memory usage is bounded by the number of cells on the frontier at any given
                    time, typically 500&ndash;2,000 nodes.
                </p>

                <h3>8.4 Typical Performance Metrics</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Route</th>
                            <th>Resolution</th>
                            <th>Ocean Cells</th>
                            <th>Cells Explored</th>
                            <th>Solve Time</th>
                            <th>Fuel Savings</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Genoa &rarr; Barcelona (~350 nm)</td>
                            <td>0.5&deg;</td>
                            <td>~3,500</td>
                            <td>~1,200</td>
                            <td>~0.5 s</td>
                            <td>2&ndash;8%</td>
                        </tr>
                        <tr>
                            <td>Gibraltar &rarr; Suez (~2,000 nm)</td>
                            <td>0.5&deg;</td>
                            <td>~18,000</td>
                            <td>~5,500</td>
                            <td>~1.2 s</td>
                            <td>3&ndash;12%</td>
                        </tr>
                        <tr>
                            <td>Rotterdam &rarr; New York (~3,500 nm)</td>
                            <td>0.5&deg;</td>
                            <td>~28,000</td>
                            <td>~8,000</td>
                            <td>~1.8 s</td>
                            <td>5&ndash;15%</td>
                        </tr>
                    </tbody>
                </table>

                <div class="alert info">
                    <strong><i class="fas fa-info-circle"></i> Fuel Savings Context</strong><br>
                    Fuel savings percentages are computed relative to the direct great-circle route
                    evaluated at the same calm-water speed. Savings vary widely depending on weather
                    severity: in calm conditions, the optimised route closely follows the great circle
                    with minimal savings; in heavy weather, deviations around storm systems can yield
                    savings of 10&ndash;15% or more. The <a href="monte-carlo.html">Monte Carlo
                    simulation</a> article describes how weather uncertainty affects these savings
                    estimates.
                </div>
            </section>

            <!-- ============================================================ -->
            <!-- REFERENCES -->
            <!-- ============================================================ -->
            <section id="references">
                <h2>References</h2>

                <ol>
                    <li>
                        Hart, P.E., Nilsson, N.J. and Raphael, B. (1968).
                        &ldquo;A Formal Basis for the Heuristic Determination of Minimum Cost Paths.&rdquo;
                        <em>IEEE Transactions on Systems Science and Cybernetics</em>, vol. 4, no. 2, pp. 100&ndash;107.
                    </li>
                    <li>
                        Dijkstra, E.W. (1959).
                        &ldquo;A Note on Two Problems in Connexion with Graphs.&rdquo;
                        <em>Numerische Mathematik</em>, vol. 1, pp. 269&ndash;271.
                    </li>
                    <li>
                        Hagiwara, H. (1989).
                        &ldquo;Weather Routing of (Sail-Assisted) Motor Vessels.&rdquo;
                        PhD Thesis, Delft University of Technology.
                    </li>
                    <li>
                        Szlapczynska, J. (2015).
                        &ldquo;Multi-objective Weather Routing with Customised Criteria and Constraints.&rdquo;
                        <em>Journal of Navigation</em>, vol. 68, no. 2, pp. 338&ndash;354.
                    </li>
                    <li>
                        Douglas, D.H. and Peucker, T.K. (1973).
                        &ldquo;Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or its Caricature.&rdquo;
                        <em>Cartographica</em>, vol. 10, no. 2, pp. 112&ndash;122.
                    </li>
                    <li>
                        IMO (2021).
                        &ldquo;Guidance on Treatment of Innovative Energy Efficiency Technologies for Calculation and Verification of the Attained EEDI and EEXI.&rdquo;
                        MEPC.1/Circ.896.
                    </li>
                    <li>
                        Vettor, R. and Guedes Soares, C. (2016).
                        &ldquo;Development of a Ship Weather Routing System.&rdquo;
                        <em>Ocean Engineering</em>, vol. 123, pp. 1&ndash;14.
                    </li>
                </ol>
            </section>

        </div>
    </main>

</div>

<!-- Footer -->
<footer class="docs-footer">
    <p>&copy; 2026 WindMar. Apache License 2.0.</p>
    <p>
        <a href="https://github.com/windmar-nav/windmar" target="_blank"><i class="fab fa-github"></i> GitHub</a>
        &nbsp;|&nbsp;
        <a href="docs.html">Main Documentation</a>
        &nbsp;|&nbsp;
        <a href="https://slmar.co">slmar.co</a>
    </p>
</footer>

<!-- Sidebar active state script -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('.sidebar-menu a[href^="#"]');

        function setActiveLink() {
            let current = '';
            sections.forEach(function(section) {
                const sectionTop = section.offsetTop - 100;
                if (window.scrollY >= sectionTop) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(function(link) {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }

        window.addEventListener('scroll', setActiveLink);
        setActiveLink();
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: '\\[', right: '\\]', display: true},
                {left: '\\(', right: '\\)', display: false}
            ],
            throwOnError: false
        });
    });
</script>

</body>
</html>
