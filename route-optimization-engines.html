<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WindMar - Route Optimization Engines</title>
    <link rel="stylesheet" href="assets/css/docs.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
</head>
<body>

<!-- Header -->
<header class="docs-header">
    <div class="docs-header-content">
        <a href="docs.html" class="docs-logo">
            <i class="fas fa-ship"></i>
            <span>WindMar</span>
        </a>
        <nav>
            <ul class="docs-nav">
                <li><a href="docs.html">Documentation</a></li>
                <li class="docs-nav-dropdown">
                    <a href="#">Technical Articles <i class="fas fa-caret-down"></i></a>
                    <ul class="docs-nav-dropdown-menu">
                        <li><a href="weather-fields.html">Weather Fields</a></li>
                        <li><a href="data-pipeline.html">Data Pipeline</a></li>
                        <li><a href="hydrodynamics.html">Hydrodynamics &amp; RAO</a></li>
                        <li><a href="astar-pathfinding.html">A* Pathfinding</a></li>
                        <li><a href="route-optimization-engines.html" class="active">Optimization Engines</a></li>
                        <li><a href="weather-data.html">Weather Acquisition</a></li>
                        <li><a href="monte-carlo.html">Monte Carlo</a></li>
                        <li><a href="open-problems.html">Open Problems</a></li>
                    </ul>
                </li>
                <li><a href="https://github.com/windmar-nav/windmar" target="_blank"><i class="fab fa-github"></i> GitHub</a></li>
                <li><a href="https://demo-windmar.slmar.co" target="_blank" class="demo-nav-link"><i class="fas fa-play-circle"></i> Live Demo</a></li>
            </ul>
        </nav>
        <a href="https://slmar.co" class="back-to-main"><i class="fas fa-arrow-left"></i> Back to Main Site</a>
    </div>
</header>

<!-- Main Layout -->
<div class="docs-container">

    <!-- Sidebar -->
    <aside class="docs-sidebar">

        <div class="sidebar-section">
            <div class="sidebar-title">Article</div>
            <ul class="sidebar-menu">
                <li><a href="#abstract"><i class="fas fa-file-alt"></i> Abstract</a></li>
                <li><a href="#introduction"><i class="fas fa-book-open"></i> Introduction</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">A* Engine</div>
            <ul class="sidebar-menu">
                <li><a href="#astar-graph"><i class="fas fa-th"></i> Graph Construction</a></li>
                <li><a href="#astar-cost"><i class="fas fa-calculator"></i> Cost Function</a></li>
                <li><a href="#astar-search"><i class="fas fa-search"></i> A* Search</a></li>
                <li><a href="#astar-smoothing"><i class="fas fa-bezier-curve"></i> Route Smoothing</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Dijkstra Engine</div>
            <ul class="sidebar-menu">
                <li><a href="#visir-graph"><i class="fas fa-cubes"></i> Time-Expanded Graph</a></li>
                <li><a href="#visir-dijkstra"><i class="fas fa-project-diagram"></i> Dijkstra Search</a></li>
                <li><a href="#visir-vsr"><i class="fas fa-tachometer-alt"></i> Voluntary Speed Reduction</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Shared Components</div>
            <ul class="sidebar-menu">
                <li><a href="#vessel-model"><i class="fas fa-ship"></i> Vessel Model</a></li>
                <li><a href="#safety-assessment"><i class="fas fa-shield-alt"></i> Safety Assessment</a></li>
                <li><a href="#safety-weight"><i class="fas fa-sliders-h"></i> Safety Weight</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Strategies</div>
            <ul class="sidebar-menu">
                <li><a href="#optimization-strategies"><i class="fas fa-balance-scale"></i> Optimization Strategies</a></li>
                <li><a href="#pareto"><i class="fas fa-chart-line"></i> Pareto Analysis</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Comparison</div>
            <ul class="sidebar-menu">
                <li><a href="#comparison"><i class="fas fa-columns"></i> Engine Comparison</a></li>
                <li><a href="#when-to-use"><i class="fas fa-compass"></i> When to Use Which</a></li>
            </ul>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Resources</div>
            <ul class="sidebar-menu">
                <li><a href="#references"><i class="fas fa-bookmark"></i> References</a></li>
                <li><a href="docs.html"><i class="fas fa-arrow-left"></i> Back to Docs</a></li>
                <li><a href="https://github.com/windmar-nav/windmar" target="_blank"><i class="fab fa-github"></i> GitHub</a></li>
            </ul>
        </div>

    </aside>

    <!-- Main Content -->
    <main class="docs-main">
        <div class="docs-content">

            <!-- ============================================================ -->
            <!-- ABSTRACT -->
            <!-- ============================================================ -->
            <section id="abstract">
                <h1>Route Optimization Engines</h1>
                <p class="docs-subtitle">Two complementary graph-search algorithms for weather-aware maritime route optimization with configurable safety&ndash;fuel trade-off</p>

                <div class="alert info">
                    <strong><i class="fas fa-info-circle"></i> Technical Article</strong><br>
                    This article describes the two route optimization engines implemented in WindMar:
                    a fine-grained <strong>A* search</strong> on a spatial grid and a coarser
                    <strong>graph-based Dijkstra</strong> on a time-expanded graph. Both are custom
                    implementations that share the same vessel model, weather data pipeline, and
                    seakeeping safety assessment. The article covers graph construction, cost functions,
                    the safety weight mechanism for controlling the fuel&ndash;safety trade-off, and the
                    three user-selectable optimization strategies.
                </div>

                <h3>Abstract</h3>
                <p>
                    WindMar provides two independent route optimization engines that attack the
                    weather routing problem from different angles. The <strong>A* engine</strong>
                    operates on a 0.5&deg; spatial grid with eight-connected adjacency and uses the
                    classical A* algorithm with an admissible fuel-based heuristic to find the
                    minimum-cost path. It excels at short-to-medium routes where fine-grained
                    coastal navigation and high spatial resolution matter. The <strong>graph-based Dijkstra
                    engine</strong> builds a
                    time-expanded graph on a coarser 1&deg; grid with 3-hour discrete time steps.
                    This allows it to account for weather evolution over the voyage duration &mdash;
                    a vessel that departs during a storm may find calmer conditions 12 hours later.
                    The Dijkstra engine also implements voluntary speed reduction (VSR), automatically
                    evaluating multiple candidate speeds per edge and selecting the cheapest safe
                    option. Both engines share a configurable <em>safety weight</em> parameter
                    that continuously interpolates between pure fuel minimization and full weather
                    avoidance, enabling the Pareto analysis mode to reveal the cost of safety.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- INTRODUCTION -->
            <!-- ============================================================ -->
            <section id="introduction">
                <h2>1. Introduction</h2>

                <p>
                    Weather routing aims to find the vessel trajectory that optimizes a given
                    objective &mdash; typically fuel consumption or voyage time &mdash; subject to
                    environmental forcing and safety constraints. The problem is computationally
                    challenging because the cost of traversing an ocean segment depends on wind,
                    waves, and currents that vary in both space and time. A route that is optimal
                    at departure may become suboptimal as weather systems evolve.
                </p>

                <p>
                    Two broad families of algorithms dominate the literature: <em>isochrone methods</em>,
                    which propagate equal-time wavefronts from the departure point (Hagiwara, 1989;
                    Mannarini et al., 2016), and <em>graph search methods</em>, which discretize the
                    ocean into a weighted graph and apply shortest-path algorithms like Dijkstra or
                    A* (Vettor &amp; Guedes Soares, 2016; Szlapczynska, 2015). WindMar implements
                    one engine from each family:
                </p>

                <ul>
                    <li>
                        <strong>A* Search</strong> &mdash; a pure spatial graph search that queries
                        weather at the estimated arrival time of each edge. Best for routes where
                        weather does not change drastically during transit.
                    </li>
                    <li>
                        <strong>graph-based Dijkstra</strong> &mdash; a time-expanded graph search
                        where each node carries a time coordinate. Weather is sampled at the node&rsquo;s
                        actual time, capturing the evolution of conditions across the voyage.
                    </li>
                </ul>

                <p>
                    Running both engines on the same voyage produces two independent solutions.
                    The user can compare the routes to understand trade-offs and build confidence
                    in the result. When the engines agree, the solution is likely robust; when they
                    disagree, the differences highlight sensitivities to grid resolution, weather
                    timing, or coastal constraints.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- A* GRAPH CONSTRUCTION -->
            <!-- ============================================================ -->
            <section id="astar-graph">
                <h2>2. A* Engine &mdash; Graph Construction</h2>

                <p>
                    The A* engine discretizes the ocean surface into a regular latitude&ndash;longitude
                    grid at a configurable resolution (default 0.5&deg;, approximately 30 nautical miles
                    at the equator). The grid is bounded by a configurable margin around the great-circle
                    path between origin and destination, keeping the search space manageable.
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Default</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Resolution</td>
                            <td>0.5&deg;</td>
                            <td>Cell size in degrees (latitude and longitude)</td>
                        </tr>
                        <tr>
                            <td>Adjacency</td>
                            <td>8-connected</td>
                            <td>Cardinal + diagonal neighbours per cell</td>
                        </tr>
                        <tr>
                            <td>Max cells</td>
                            <td>50,000</td>
                            <td>Upper bound on cells explored before termination</td>
                        </tr>
                        <tr>
                            <td>Speed range</td>
                            <td>8&ndash;18 kts</td>
                            <td>Bounded by user calm-water speed</td>
                        </tr>
                    </tbody>
                </table>

                <p>
                    Land cells are excluded using a high-resolution global land mask. Each edge between
                    adjacent ocean cells is additionally checked for land crossings via ray&ndash;casting,
                    ensuring that routes do not cut across peninsulas or narrow isthmuses. The fine 0.5&deg;
                    resolution allows the A* engine to navigate through straits and along coastlines
                    where the coarser Dijkstra grid cannot.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- A* COST FUNCTION -->
            <!-- ============================================================ -->
            <section id="astar-cost">
                <h2>3. A* Engine &mdash; Cost Function</h2>

                <p>
                    The cost of traversing an edge from cell \(i\) to cell \(j\) is computed by the full
                    <a href="hydrodynamics.html">hydrodynamic vessel model</a>, incorporating calm-water
                    resistance, wind resistance, wave-added resistance, and the effect of ocean currents
                    on speed over ground. The result is the actual fuel consumption in metric tonnes for
                    the leg at the given speed and weather conditions.
                </p>

                <p>
                    To prevent the optimizer from exploiting slow-steaming (reducing speed to save fuel
                    per mile at the cost of excessive voyage time), a <em>time-value penalty</em>
                    \(\lambda_t\) is added. This penalty is calibrated as the fuel consumed by one hour
                    of steaming at the user&rsquo;s calm-water speed:
                </p>

                \[
                    C(i \to j) = \bigl[\,\text{fuel}(i,j) \;\cdot\; \phi_{\text{safety}} \;\cdot\; \phi_{\text{zone}}\,\bigr]
                    \;+\; \lambda_t \cdot t(i,j)
                \]

                <p>where:</p>
                <ul>
                    <li>\(\text{fuel}(i,j)\) is the fuel consumption for the leg (mt)</li>
                    <li>\(\phi_{\text{safety}}\) is the dampened safety penalty (see <a href="#safety-weight">Section 8</a>)</li>
                    <li>\(\phi_{\text{zone}}\) is the regulatory zone penalty</li>
                    <li>\(\lambda_t\) is the time-value penalty (mt/hour)</li>
                    <li>\(t(i,j)\) is the transit time for the leg (hours)</li>
                </ul>

                <p>
                    When the optimization target is time rather than fuel, the cost simplifies to
                    \(C(i \to j) = t(i,j) \cdot \phi_{\text{safety}} \cdot \phi_{\text{zone}}\).
                </p>

                <h3>3.1 Variable-Speed Optimization</h3>
                <p>
                    After A* finds the minimum-cost path at the user&rsquo;s calm-water speed, a
                    post-processing step re-evaluates each leg at multiple candidate speeds (8&ndash;18 kts
                    in 0.5-knot increments) to find the per-leg optimal speed. The function
                    <code>_find_optimal_speed</code> selects the speed that minimizes the combined
                    fuel + time-value cost for each leg, incorporating the safety weight penalty.
                    This captures situations where a headwind makes it cheaper to slow down on one
                    leg while a following current makes it efficient to speed up on another.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- A* SEARCH -->
            <!-- ============================================================ -->
            <section id="astar-search">
                <h2>4. A* Search Algorithm</h2>

                <p>
                    A* is a best-first graph search that uses an <em>admissible heuristic</em>
                    \(h(n)\) to guide exploration toward the goal. The heuristic must never
                    overestimate the true cost to reach the destination. WindMar&rsquo;s heuristic
                    is based on the great-circle distance to the destination, the maximum attainable
                    speed, and a conservative fuel rate:
                </p>

                \[
                    h(n) = d_{\text{gc}}(n, \text{dest}) \;\cdot\; \min_{v \in V}\!\left[\frac{\text{fuel}(v)}{v} + \frac{\lambda_t}{v}\right]
                \]

                <p>
                    where \(d_{\text{gc}}\) is the great-circle distance in nautical miles and
                    the minimization finds the speed with the lowest cost-per-mile in calm conditions.
                    This is admissible because weather can only increase cost, never decrease it below
                    the calm-water optimum.
                </p>

                <p>
                    The algorithm maintains a priority queue ordered by \(f(n) = g(n) + h(n)\),
                    where \(g(n)\) is the cost from origin to node \(n\). At each step, the node
                    with the lowest \(f\)-score is expanded, and its 8 neighbours are evaluated
                    via the cost function. The search terminates when the destination cell is popped
                    from the queue, guaranteeing optimality.
                </p>

                <p>
                    For typical Mediterranean routes, the heuristic prunes 60&ndash;80% of the grid,
                    reducing solve times to 0.5&ndash;2 seconds.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- A* ROUTE SMOOTHING -->
            <!-- ============================================================ -->
            <section id="astar-smoothing">
                <h2>5. Route Smoothing</h2>

                <p>
                    The raw A* path follows the discrete grid, producing staircase-like waypoints at
                    0.5&deg; intervals. Post-processing applies <strong>Douglas&ndash;Peucker
                    simplification</strong> (Douglas &amp; Peucker, 1973) to reduce waypoint density
                    while preserving the route&rsquo;s shape. Each candidate simplification is checked
                    for land crossings &mdash; if the straight-line shortcut crosses land, the original
                    waypoints are retained.
                </p>

                <p>
                    After smoothing, the route typically has 10&ndash;30 waypoints instead of
                    50&ndash;200 grid cells, making it practical for navigation and display. The final
                    statistics (fuel, time, distance) are recomputed along the smoothed path to ensure
                    accuracy.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- VISIR TIME-EXPANDED GRAPH -->
            <!-- ============================================================ -->
            <section id="visir-graph">
                <h2>6. Dijkstra Engine &mdash; Time-Expanded Graph</h2>

                <p>
                    The Dijkstra engine extends the spatial grid with a <em>time dimension</em>,
                    creating a 3-D graph where each node is identified by the tuple
                    \((\text{row},\, \text{col},\, \text{time\_step})\). This allows the algorithm
                    to query weather conditions at the actual time the vessel would arrive at each
                    cell, rather than assuming static weather as a spatial-only grid does.
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Default</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Spatial resolution</td>
                            <td>1.0&deg;</td>
                            <td>Coarser grid to keep the 3-D graph tractable</td>
                        </tr>
                        <tr>
                            <td>Temporal resolution</td>
                            <td>3 hours</td>
                            <td>Discrete time steps for weather evolution</td>
                        </tr>
                        <tr>
                            <td>Adjacency</td>
                            <td>8-connected</td>
                            <td>Diagonals checked first for direct-line progress</td>
                        </tr>
                        <tr>
                            <td>Max nodes</td>
                            <td>100,000</td>
                            <td>Exploration budget for the 3-D graph</td>
                        </tr>
                        <tr>
                            <td>Speed candidates</td>
                            <td>3 per edge</td>
                            <td>Linearly spaced between 10 and 18 kts</td>
                        </tr>
                    </tbody>
                </table>

                <p>
                    The time-expanded structure means that two nodes at the same spatial location
                    but different time steps are distinct. A vessel arriving at cell (5, 10) at
                    hour 6 encounters different weather than one arriving at hour 12. This is the
                    key advantage of the Dijkstra approach for long ocean crossings where weather
                    systems move and evolve during transit.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- VISIR DIJKSTRA -->
            <!-- ============================================================ -->
            <section id="visir-dijkstra">
                <h2>7. Dijkstra Engine &mdash; Dijkstra Search</h2>

                <p>
                    Despite using Dijkstra&rsquo;s algorithm as its foundation, the Dijkstra engine
                    incorporates an <strong>admissible heuristic</strong> (A*-guided Dijkstra) to
                    focus exploration toward the destination. The heuristic is the same
                    great-circle-based minimum cost-per-mile estimate used by the A* engine:
                </p>

                \[
                    h(n) = d_{\text{gc}}(n, \text{dest}) \;\cdot\; \min_{v \in V}\!\left[\frac{\text{fuel}(v)}{v} + \frac{\lambda_t}{v}\right]
                \]

                <p>
                    The heuristic is computed once per spatial cell and cached, since it depends only
                    on distance to the destination and calm-water fuel rates. This dramatically reduces
                    the number of nodes explored compared to pure Dijkstra, especially on long routes.
                </p>

                <h3>7.1 Isochrone Expansion</h3>
                <p>
                    The search proceeds in an isochrone-like fashion: when a node at time step
                    \(k\) is expanded, each spatial neighbour is evaluated at multiple candidate
                    speeds. The travel time determines the time step of the resulting neighbour node:
                </p>

                \[
                    k_{\text{neighbour}} = k + \max\!\left(1,\; \text{round}\!\left(\frac{t_{\text{travel}}}{\Delta t}\right)\right)
                \]

                <p>
                    where \(\Delta t\) is the temporal resolution (default 3 hours). This maps
                    continuous travel times onto the discrete time grid while ensuring monotone
                    progress through time. The algorithm naturally handles the coupling between
                    speed choice and weather exposure: a slower speed means the vessel arrives later,
                    potentially encountering different (better or worse) conditions.
                </p>

                <h3>7.2 Time-Value Penalty</h3>
                <p>
                    Both engines use the same time-value penalty \(\lambda_t\) to prevent the optimizer
                    from gaming voyage time. Each extra hour of transit is penalized by the fuel that
                    would be consumed during one hour at the user&rsquo;s calm-water speed. This
                    anchors the optimizer&rsquo;s time preferences to a physically meaningful scale
                    and produces routes whose total voyage time remains within a reasonable margin
                    (typically 15&ndash;30%) of the direct great-circle transit.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- VOLUNTARY SPEED REDUCTION -->
            <!-- ============================================================ -->
            <section id="visir-vsr">
                <h2>7.3 Voluntary Speed Reduction</h2>

                <p>
                    A distinguishing feature of the Dijkstra engine is <strong>voluntary speed
                    reduction (VSR)</strong>. At each edge, the algorithm evaluates 3 candidate
                    speeds linearly spaced between 10 kts and the vessel&rsquo;s service speed
                    (+2 kts margin). For each candidate speed, the safety constraints are checked:
                </p>

                <ul>
                    <li>
                        If the safety factor is \(\infty\) (dangerous conditions), that speed is
                        <strong>skipped</strong> &mdash; a hard constraint that applies regardless
                        of optimization settings.
                    </li>
                    <li>
                        If all candidate speeds are unsafe, the entire edge is blocked, forcing
                        the route to detour around the hazardous area.
                    </li>
                    <li>
                        Otherwise, the cheapest safe (speed, cost) pair is selected, potentially
                        choosing a lower speed to stay within safety limits.
                    </li>
                </ul>

                <p>
                    VSR faithfully models real-world slow-steaming in bad weather. A ship master
                    facing heavy head seas will reduce speed to limit slamming and parametric roll.
                    The Dijkstra engine captures this decision automatically during the graph search.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- VESSEL MODEL -->
            <!-- ============================================================ -->
            <section id="vessel-model">
                <h2>8. Shared Components &mdash; Vessel Model</h2>

                <p>
                    Both engines use the same <code>VesselModel</code> instance to compute fuel
                    consumption for each leg. The model implements the full propulsion chain
                    described in the <a href="hydrodynamics.html">Hydrodynamics &amp; RAO</a>
                    article:
                </p>

                <ul>
                    <li><strong>Calm-water resistance</strong> &mdash; Holtrop&ndash;Mennen regression</li>
                    <li><strong>Wind resistance</strong> &mdash; Fujiwara wind loading model</li>
                    <li><strong>Wave-added resistance</strong> &mdash; STAWAVE-2 method (ITTC, 2014)</li>
                    <li><strong>Current effects</strong> &mdash; Speed over ground adjustment</li>
                    <li><strong>SFOC curve</strong> &mdash; Engine-specific fuel consumption</li>
                </ul>

                <p>
                    The vessel model is configured once with ship particulars (length, beam, draft,
                    displacement, block coefficient) and the loading condition (laden or ballast).
                    Each cost function call queries the model with speed, weather, and distance,
                    receiving back the fuel consumption in metric tonnes.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- SAFETY ASSESSMENT -->
            <!-- ============================================================ -->
            <section id="safety-assessment">
                <h2>9. Shared Components &mdash; Safety Assessment</h2>

                <p>
                    The seakeeping safety model evaluates each leg for six operational criteria:
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Criterion</th>
                            <th>Metric</th>
                            <th>Threshold</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Excessive roll</td>
                            <td>RMS roll angle</td>
                            <td>&gt; 6&deg; (laden) / 8&deg; (ballast)</td>
                        </tr>
                        <tr>
                            <td>Parametric roll risk</td>
                            <td>Wave-to-ship length ratio</td>
                            <td>0.8&ndash;1.3 &times; L<sub>pp</sub></td>
                        </tr>
                        <tr>
                            <td>Slamming risk</td>
                            <td>Relative bow motion</td>
                            <td>Forefoot emergence probability</td>
                        </tr>
                        <tr>
                            <td>Deck wetness</td>
                            <td>Green water probability</td>
                            <td>Freeboard exceedance</td>
                        </tr>
                        <tr>
                            <td>Vertical acceleration</td>
                            <td>RMS at bridge</td>
                            <td>&gt; 0.2g</td>
                        </tr>
                        <tr>
                            <td>Propeller emergence</td>
                            <td>Relative stern motion</td>
                            <td>Propeller tip clearance</td>
                        </tr>
                    </tbody>
                </table>

                <p>
                    Each criterion returns a multiplicative <em>safety factor</em>. Below the threshold,
                    the factor is 1.0 (no penalty). Above the threshold, the factor grows with severity.
                    At extreme conditions, the factor becomes \(\infty\), representing a hard constraint
                    that blocks traversal regardless of optimization settings.
                </p>

                <p>
                    The safety model produces the same factors for both engines, ensuring that their
                    route comparisons are driven by algorithmic differences rather than different
                    safety evaluations.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- SAFETY WEIGHT -->
            <!-- ============================================================ -->
            <section id="safety-weight">
                <h2>10. The Safety Weight Mechanism</h2>

                <p>
                    Both engines accept a <strong>safety weight</strong> parameter
                    \(w \in [0, 1]\) that controls how much influence the safety factor
                    has on the cost function. The raw safety factor \(S_f\) from the seakeeping
                    model is dampened by raising it to the power of \(w\):
                </p>

                \[
                    \phi_{\text{safety}} = \begin{cases}
                        1.0 & \text{if } S_f \leq 1.0 \text{ or } w = 0 \\
                        S_f^{\,w} & \text{if } S_f > 1.0 \text{ and } w > 0 \\
                        \infty & \text{if } S_f = \infty \quad\text{(hard constraint, always)}
                    \end{cases}
                \]

                <p>
                    This formulation has several desirable properties:
                </p>

                <ul>
                    <li>
                        <strong>At \(w = 0\)</strong> &mdash; the dampened factor is always 1.0.
                        Safety has zero influence on the cost function. The optimizer finds the
                        pure fuel-optimal path. Hard constraints (\(S_f = \infty\)) still apply,
                        blocking dangerous conditions.
                    </li>
                    <li>
                        <strong>At \(w = 1\)</strong> &mdash; the full safety factor is applied.
                        Routes actively avoid areas with elevated safety factors, even at the cost
                        of extra fuel and time.
                    </li>
                    <li>
                        <strong>At \(0 &lt; w &lt; 1\)</strong> &mdash; a continuous interpolation
                        between fuel-optimal and safety-optimal behavior. The exponent dampens
                        large safety factors sublinearly: a factor of 4.0 at \(w = 0.5\) becomes
                        \(4.0^{0.5} = 2.0\), halving the penalty.
                    </li>
                    <li>
                        <strong>Hard constraints always apply</strong> &mdash; regardless of \(w\),
                        conditions that exceed the dangerous threshold (\(S_f = \infty\)) always
                        block traversal. This ensures that no optimization strategy can route
                        through truly dangerous seas.
                    </li>
                </ul>

                <div class="alert info">
                    <strong><i class="fas fa-info-circle"></i> Why Exponentiation?</strong><br>
                    Using \(S_f^w\) rather than a linear blend \(1 + w(S_f - 1)\) preserves the
                    multiplicative structure of the cost function. It also maps the unit interval
                    \([0,1]\) onto a smooth family of cost surfaces, making the Pareto frontier
                    well-behaved. At \(w = 0\), all safety factors collapse to 1.0; at \(w = 1\),
                    the original factors are fully recovered.
                </div>
            </section>

            <!-- ============================================================ -->
            <!-- OPTIMIZATION STRATEGIES -->
            <!-- ============================================================ -->
            <section id="optimization-strategies">
                <h2>11. Optimization Strategies</h2>

                <p>
                    WindMar exposes the safety weight through three named strategies in the user
                    interface:
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Strategy</th>
                            <th>Safety Weight \(w\)</th>
                            <th>Behavior</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Fuel Optimal</strong></td>
                            <td>0.0</td>
                            <td>
                                Pure fuel minimization. The optimizer finds the cheapest route
                                without any soft safety penalties. Hard constraints still block
                                extreme conditions. Produces the most fuel-efficient result.
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Pareto</strong></td>
                            <td>0.0, 0.5, 1.0</td>
                            <td>
                                Runs both engines at three safety weights (6 optimizations in parallel).
                                Displays a comparison table showing how fuel consumption changes as
                                safety emphasis increases. Helps the operator decide how much extra
                                fuel the safety margin is worth.
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Safety Priority</strong></td>
                            <td>1.0</td>
                            <td>
                                Full weather avoidance. Routes actively detour around areas with
                                elevated safety factors. May use significantly more fuel and time
                                in exchange for calmer seas and reduced motion severity.
                            </td>
                        </tr>
                    </tbody>
                </table>

                <p>
                    The default strategy is <strong>Fuel Optimal</strong>. In this mode, the
                    optimized route should consume less fuel than the direct (great-circle) route,
                    since the optimizer can exploit favourable currents and avoid headwinds while
                    incurring no safety penalties for mild-to-moderate weather.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- PARETO ANALYSIS -->
            <!-- ============================================================ -->
            <section id="pareto">
                <h2>12. Pareto Analysis</h2>

                <p>
                    The Pareto strategy runs <strong>6 independent optimizations</strong>: each of
                    the 2 engines at safety weights \(w \in \{0.0,\, 0.5,\, 1.0\}\). All 6 requests
                    execute in parallel, producing a matrix of results:
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Engine</th>
                            <th>\(w = 0.0\) (Fuel)</th>
                            <th>\(w = 0.5\) (Balanced)</th>
                            <th>\(w = 1.0\) (Safety)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>A*</td>
                            <td>Fuel \(\downarrow\), Safety \(\downarrow\)</td>
                            <td>Fuel &uarr;, Safety &uarr;</td>
                            <td>Fuel \(\uparrow\!\uparrow\), Safety \(\uparrow\!\uparrow\)</td>
                        </tr>
                        <tr>
                            <td>Dijkstra</td>
                            <td>Fuel \(\downarrow\), Safety \(\downarrow\)</td>
                            <td>Fuel &uarr;, Safety &uarr;</td>
                            <td>Fuel \(\uparrow\!\uparrow\), Safety \(\uparrow\!\uparrow\)</td>
                        </tr>
                    </tbody>
                </table>

                <p>
                    The Pareto table in the UI shows the original (direct) route alongside the three
                    solutions for each engine, with colour-coded fuel deltas: <span style="color: #22c55e;">green</span>
                    when the optimized route saves fuel, <span style="color: #f59e0b;">amber</span> when it
                    costs more. A safety icon summarizes the worst-case condition along each route.
                </p>

                <p>
                    This gives the operator a clear picture of the <em>cost of safety</em>. For example,
                    if the Fuel Optimal route saves 3% fuel but has weather warnings, while the Safety
                    route costs 8% more fuel but avoids all warnings, the operator can make an informed
                    trade-off based on the specific voyage requirements.
                </p>
            </section>

            <!-- ============================================================ -->
            <!-- ENGINE COMPARISON -->
            <!-- ============================================================ -->
            <section id="comparison">
                <h2>13. Engine Comparison</h2>

                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>A* Engine</th>
                            <th>Dijkstra Engine</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Algorithm</strong></td>
                            <td>A* search (best-first with admissible heuristic)</td>
                            <td>A*-guided Dijkstra on time-expanded graph</td>
                        </tr>
                        <tr>
                            <td><strong>Graph type</strong></td>
                            <td>2-D spatial \((\text{row}, \text{col})\)</td>
                            <td>3-D spatio-temporal \((\text{row}, \text{col}, \text{time\_step})\)</td>
                        </tr>
                        <tr>
                            <td><strong>Spatial resolution</strong></td>
                            <td>0.5&deg; (~30 nm)</td>
                            <td>1.0&deg; (~60 nm)</td>
                        </tr>
                        <tr>
                            <td><strong>Temporal resolution</strong></td>
                            <td>Static (weather at estimated arrival)</td>
                            <td>3-hour discrete time steps</td>
                        </tr>
                        <tr>
                            <td><strong>Speed optimization</strong></td>
                            <td>Post-processing (per-leg variable speed)</td>
                            <td>Inline (VSR during graph search)</td>
                        </tr>
                        <tr>
                            <td><strong>Land avoidance</strong></td>
                            <td>Cell exclusion + edge ray-casting</td>
                            <td>Cell exclusion only (coastal clips fixed in post-processing)</td>
                        </tr>
                        <tr>
                            <td><strong>Heuristic</strong></td>
                            <td>Great-circle distance &times; min cost/nm</td>
                            <td>Same heuristic, cached per spatial cell</td>
                        </tr>
                        <tr>
                            <td><strong>Post-processing</strong></td>
                            <td>Douglas&ndash;Peucker smoothing + variable speed</td>
                            <td>Waypoint extraction from 3-D path</td>
                        </tr>
                        <tr>
                            <td><strong>Typical solve time</strong></td>
                            <td>0.5&ndash;2 s</td>
                            <td>1&ndash;5 s</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- ============================================================ -->
            <!-- WHEN TO USE WHICH -->
            <!-- ============================================================ -->
            <section id="when-to-use">
                <h2>14. When to Use Which Engine</h2>

                <p>
                    Both engines run automatically on every optimization request, so the user always
                    has both results to compare. However, each engine has characteristics that make it
                    better suited to certain route profiles:
                </p>

                <h3>14.1 A* Engine Strengths</h3>
                <ul>
                    <li>
                        <strong>Coastal and confined waters</strong> &mdash; The fine 0.5&deg; grid
                        resolves narrow straits, island passages, and coastal features that the Dijkstra
                        engine&rsquo;s 1&deg; grid cannot navigate.
                    </li>
                    <li>
                        <strong>Short routes</strong> &mdash; When transit time is under 24 hours,
                        weather evolution is minimal and the static-weather assumption is reasonable.
                    </li>
                    <li>
                        <strong>Speed</strong> &mdash; Fewer dimensions mean faster solve times,
                        typically under 1 second for Mediterranean routes.
                    </li>
                </ul>

                <h3>14.2 Dijkstra Engine Strengths</h3>
                <ul>
                    <li>
                        <strong>Long ocean crossings</strong> &mdash; On multi-day voyages, weather
                        systems move and evolve. The time-expanded graph captures this, potentially
                        finding routes that &ldquo;wait out&rdquo; a storm by choosing a longer but
                        calmer path.
                    </li>
                    <li>
                        <strong>Rapidly changing weather</strong> &mdash; When forecast fields show
                        significant weather evolution (e.g., a developing low-pressure system), the
                        Dijkstra engine can exploit temporal windows that the A* engine misses.
                    </li>
                    <li>
                        <strong>Speed adaptation</strong> &mdash; VSR is integrated into the search,
                        automatically reducing speed in heavy seas rather than treating it as a
                        post-processing adjustment.
                    </li>
                </ul>

                <div class="alert info">
                    <strong><i class="fas fa-info-circle"></i> Dual-Engine Philosophy</strong><br>
                    WindMar runs both engines by default and presents the results side by side.
                    When both engines agree on a route, confidence is high. When they disagree,
                    the differences highlight where spatial resolution, temporal modelling, or
                    speed adaptation matter most. The Pareto strategy further enriches the comparison
                    by varying the safety weight across three levels.
                </div>
            </section>

            <!-- ============================================================ -->
            <!-- REFERENCES -->
            <!-- ============================================================ -->
            <section id="references">
                <h2>References</h2>

                <ol>
                    <li>
                        Mannarini, G., Pinardi, N., Coppini, G., Oddo, P. and Iafrati, A. (2016).
                        &ldquo;VISIR-I: Small Vessel &mdash; Least-Time Nautical Routes Using Wave Forecasts.&rdquo;
                        <em>Geoscientific Model Development</em>, vol. 9, pp. 1597&ndash;1625.
                    </li>
                    <li>
                        Hart, P.E., Nilsson, N.J. and Raphael, B. (1968).
                        &ldquo;A Formal Basis for the Heuristic Determination of Minimum Cost Paths.&rdquo;
                        <em>IEEE Transactions on Systems Science and Cybernetics</em>, vol. 4, no. 2, pp. 100&ndash;107.
                    </li>
                    <li>
                        Dijkstra, E.W. (1959).
                        &ldquo;A Note on Two Problems in Connexion with Graphs.&rdquo;
                        <em>Numerische Mathematik</em>, vol. 1, pp. 269&ndash;271.
                    </li>
                    <li>
                        Hagiwara, H. (1989).
                        &ldquo;Weather Routing of (Sail-Assisted) Motor Vessels.&rdquo;
                        PhD Thesis, Delft University of Technology.
                    </li>
                    <li>
                        Szlapczynska, J. (2015).
                        &ldquo;Multi-objective Weather Routing with Customised Criteria and Constraints.&rdquo;
                        <em>Journal of Navigation</em>, vol. 68, no. 2, pp. 338&ndash;354.
                    </li>
                    <li>
                        Vettor, R. and Guedes Soares, C. (2016).
                        &ldquo;Development of a Ship Weather Routing System.&rdquo;
                        <em>Ocean Engineering</em>, vol. 123, pp. 1&ndash;14.
                    </li>
                    <li>
                        Douglas, D.H. and Peucker, T.K. (1973).
                        &ldquo;Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or its Caricature.&rdquo;
                        <em>Cartographica</em>, vol. 10, no. 2, pp. 112&ndash;122.
                    </li>
                    <li>
                        ITTC (2014).
                        &ldquo;Recommended Procedures and Guidelines: Prediction of Power Increase in Irregular Waves from Model Tests.&rdquo;
                        ITTC 7.5-02-07-02.2.
                    </li>
                </ol>
            </section>

        </div>
    </main>

</div>

<!-- Footer -->
<footer class="docs-footer">
    <p>&copy; 2026 WindMar. Apache License 2.0.</p>
    <p>
        <a href="https://github.com/windmar-nav/windmar" target="_blank"><i class="fab fa-github"></i> GitHub</a>
        &nbsp;|&nbsp;
        <a href="docs.html">Main Documentation</a>
        &nbsp;|&nbsp;
        <a href="https://slmar.co">slmar.co</a>
    </p>
</footer>

<!-- Sidebar active state script -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('.sidebar-menu a[href^="#"]');

        function setActiveLink() {
            let current = '';
            sections.forEach(function(section) {
                const sectionTop = section.offsetTop - 100;
                if (window.scrollY >= sectionTop) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(function(link) {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }

        window.addEventListener('scroll', setActiveLink);
        setActiveLink();
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: '\\[', right: '\\]', display: true},
                {left: '\\(', right: '\\)', display: false}
            ],
            throwOnError: false
        });
    });
</script>

</body>
</html>
